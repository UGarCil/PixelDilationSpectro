# Created on Jan 8th 2025 by Uriel Garcilazo Cruz. Code generated by LLM indicated as *LLM*
'''
This program takes a batch of images as input and provides a simple pygame based interface to delimit the area in a 
spectrogram that will be used for thresholding and dilation to give the effect of a thicker line.

Once the area has been setup, the program will perform the operations on a subset of the original image and perform the 
operations. Once completed, they will be placed on top of the original image
'''

from constants import *
from utils import *

# DD. ORIG_IMAGE
# img = np.array
# interp. an image opened via opencv
calibIMG = Image.open("./calibration.png")
calibIMG_arr = np.array(calibIMG)
SCREEN = calibIMG_arr.shape[1],calibIMG_arr.shape[0]
calibIMG_arr = np.stack((calibIMG_arr,)*3, axis=-1)*255
calibIMG_surf = np.flipud(np.rot90(calibIMG_arr))

display = pygame.display.set_mode(SCREEN)

# DD >> RECT_SELECT
# rect_sel = Recsel()
# interp. a bounding box, defined once, to contain the operations performed on pixels
class Recsel():
    def __init__(self):
        self.reset()
    
    def reset(self):
        self.x1 = -100 
        self.y1 = -100 
        self.x2 = -100
        self.y2 = -100
        # self.pressed_0_0 = True #initial press, defines topleft corner of the box
        # self.pressed_1_0 = False #dragging mode, allows to define a rectangle that ends at pointer
        # self.pressed_1_1 = False #completion mode. When True the program initiates other algorithms
        self.press_array = 0
        self.are_coor_set = False #determines whether to set the x,y corner of the bounding box, only once
        # self.rect = pygame.Rect(self.x, self.y, 1,1)
        # self.rect.topleft = (self.x, self.y)
    
    def draw(self,display):
        if self.press_array == 1:
            mx,my = pygame.mouse.get_pos()
            pygame.draw.rect(display,"green",(self.x1, self.y1, mx - self.x1, my - self.y1),1)

    def update(self):
        # update the index of the button pressed
        if self.press_array < 2:
            self.press_array += 1
        # evaluate and update position in x and y
        if self.press_array == 1 and not self.are_coor_set:
            mx,my = pygame.mouse.get_pos()
            self.x1 = mx 
            self.y1 = my
            self.are_coor_set = True
        # evaluate if ready for processing
        if self.press_array == 2:
            self.x2,self.y2 = pygame.mouse.get_pos()
            self.press_array = 3
            
            process_images((self.x1,self.y1),(self.x2,self.y2))
            
            


rect_sel = Recsel()
        
def draw():
    display.fill("#1e1e1e")
    surf = pygame.surfarray.make_surface(calibIMG_surf)
    display.blit(surf,(0,0))
    rect_sel.draw(display)
    pygame.display.flip()


def update():
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
        if event.type == pygame.MOUSEBUTTONUP:
            rect_sel.update()
        
        if event.type == pygame.KEYUP:
            if event.key == pygame.K_ESCAPE:
                rect_sel.reset()
        
        

while True:
    draw()
    update()